\large{
Di seguito saranno trattati i problemi riscontrati nello stato dell'arte.
Come accennato nel capitolo 2, è palese la difficoltà nel reperire un software che tratti in maniera esaustiva ed esclusiva delle sole primitive di interazione dell'utente nell'ambito dei grafi. Anche avendo la possibilità di una visualizzazione spesso in tali sistemi non si ha però una struttura fissa alla base. Ne è un esempio GraphVis. 
Ad aggravare il tutto c'è anche il problema che
\begin{center}
\textbf{le primitive di interazione e le operazioni utente viste per quanto riguarda i grafi non possono essere utilizzare per la rappresentazione di grafi clusterizzati.}
\end{center}
Tali primitive di interazione, che sono ben chiare e fisse per quanto concerne non solo la realizzazione ma anche la modifica e la possibilità di analisi di una visualizzazione per un grafo, tendono a portare a degli errori oppure ad una non completezza nel caso dei grafi clusterizzati.
Avendo definito un grafo clusterizzato come una coppia $<G,T>$ con Underliyng Graph $G$ e inclusion tree $T$, le primitive di interazione riportate nel capitolo due andrebbero a coprire solo ciò che concerne il grafo $G$.
Risulta dunque necessaria una analisi iniziale sulla struttura che compone il grafo clusterizzato di modo che sia possibile avere una lista di primitive standardizzate e di operazioni di trasformazione universali che potranno essere poi impiegate in qualunque sistema di creazione e visualizzazione di grafi clusterizzati.
L'obiettivo principale posto è dunque quello di poter trovare una soluzione al problema dell'assenza di primitive di interazione relative a queste strutture.
In altre parole il lavoro svolto verterà alla risoluzione dei problemi elencati di seguito:
\begin{itemize}
	\item Le primitive viste per i grafi non sono utilizzabili per i grafi clusterizzati;
	\item Non vi sono operazioni di semplificazione per i grafi clusterizzati;
	\item I software per la realizzazione di visualizzazioni grafiche di grafi non sono esaustivi e non possono essere utilizzati per la rappresentazione di grafi clusterizzati.
\end{itemize}
Una volta analizzate e fissate le primitive di interazione è quindi necessario sopperire anche al problema dell'assenza di software relativi a queste strutture dati. 
Sarà dunque mostrato un utilizzo delle soluzioni, riportate risolvendo i primi due problemi, mediante la creazione di un editor per grafi clusterizzati che servirà da mero esempio pratico di come sia possibile, una volta analizzate sotto gli aspetti teorici, poter utilizzare queste primitive di interazione in un caso pratico. Il sistema in esempio, mediante le primitive analizzate in precedenza, avrà la capacità di eseguire vari task. Le varie modalità di utilizzo sono dunque riportate di seguito in ordine di tipica esecuzione di una sessione di lavoro:
\newpage
\begin{itemize}
	\item[I] Creazione dei dati relativi ad un grafo clusterizzato;
	\item[II] Visualizzazione mediante diverse interfacce;
	\item[III] Modifica della struttura dati e della sua rappresentazione,
	\item[IV] Esecuzione di operazioni di semplificazione.
\end{itemize}
Per il conseguimento dell'obiettivo (I) sono state utilizzate le strutture dati permettono un collegamento diretto tra i dati, la loro modifica e la loro rappresentazione sul piano di lavoro.\\
Per permettere una visualizzazione completa (II) si sceglierà di dare all'utente la possibilità di creare/eliminare e modificare ogni elemento dell'underlying graph potendo sempre passare ad una visualizzazione dell'Inclusion Tree che risulta essere d'aiuto durante le modifiche e soprattutto dopo la riduzione a grafo flat.
La creazione dell'editor di esempio inoltre rientra in tutta quella branca dell'informatica definita ingegneria del software che divide la creazione del progetto in tre parti distinte ma sviluppate quasi in parallelo: analisi, progettazione ed implementazione. Sulla base della specifica dei requisiti prodotta dall'analisi, la progettazione ne definir\`a i modi in cui tali requisiti saranno soddisfatti, entrando nel merito della struttura che dovr\`a essere data al sistema software che deve essere implementato. In particolare durante il lavoro svolto \`e stata utilizzata una metodologia definita come \textbf{Agile}.
Nell'ingegneria del software, l'espressione "metodologia agile", o sviluppo agile del software, si riferisce a un insieme di metodi di sviluppo del software emersi a partire dai primi anni 2000. Di grande spunto \`e stato anche il libro "Agile Software Development: Principles, Patterns, and Practices"\cite{AG:02}. I metodi agili si contrappongono al modello a cascata e altri processi software tradizionali, proponendo un approccio meno strutturato e focalizzato sull'obiettivo di consegnare al cliente, in tempi brevi e frequentemente, software funzionante e di qualit\`a.
Questi principi sono definiti nel "Manifesto per lo sviluppo agile del software"~\cite{agile2001},
pubblicato nel 2001 da Kent Beck, Robert C. Martin e Martin Fowler in cui si specificano le seguenti considerazioni:\\
\begin{center}
	\textbf{Gli individui e le interazioni} p\`u che i processi e gli strumenti\\
	\textbf{Il software funzionante} pi\`u che la documentazione esaustiva\\
	\textbf{La collaborazione col cliente} pi\`u che la negoziazione dei contratti\\
	\textbf{Rispondere al cambiamento} pi\`u che seguire un piano\\
\end{center}

Fra le pratiche promosse dai metodi agili si trovano: la formazione di team di sviluppo piccoli, poli-funzionali e auto-organizzati, lo sviluppo iterativo e incrementale, la pianificazione adattiva, e il coinvolgimento diretto e continuo del cliente nel processo di sviluppo.

}
